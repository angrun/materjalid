EX06
====


Eesmärk
----
Antud ülesanne eesmärk on realiseerida köök kohvimasinatega. Selle ülesanne puhul on eriti oluline koodi struktureerimine, 
sest ülesannega võib võimatu keerulisemaks minna, oluline on ikka kindel ja loogiline koodi ülesehitus. Jälgida tuleb kindlasti 
ka SOLID konseptisooni (https://en.wikipedia.org/wiki/SOLID_(object-oriented_design). Tõsi küll on see, et ülesannel eksisteerib
19375 erinevat põnevat lahendust, seega see on ainult üks nendest võimalikest viisidest.
Vaadates ülesanne teksti, siis võib märkida unnik alampealkirja, mis võiks viidata mingi klassile. Alustame siis kohvimasinast.

Kohvimasin
----
Kuna ülesannes on nõutud realiseerida 3 tüüpi kohvimasinat, siis üks võimalus on kuidas seda teha võiks olla järgmine

.. code-block:: java

  public class CoffeMachine {}
  public class ClassicCoffeeMachine extends CoffeMachine {}
  public class AutomatedCoffeeMachine extends CoffeMachine {}
  public class CapsuleCoffeeMachine extends CoffeMachine {}

Ehk siis, me teeme CoffeeMachine ülemklassina (kuna ta on kõige tüüpilisem masin) ja sinna paneme kirja kõik meetodid, 
mis on temga seotud. Olgu masinad on erinevad, neil leiduvad ka samasugused meetodid nagu

.. code-block:: java

    public WaterContainer getWaterContainer() {
        return waterContainer;
    }
    public BeansContainer getBeansContainer() {
        return beansContainer;
    }
    public MilkContainer getMilkContainer() {
        return milkContainer;
    }
    public RubbishContainer getRubbishContainer() {
        return rubbishContainer;
    }
    
Kuna AutomatedCoffeeMachine ja CapsuleCoffeeMachine pärivad CoffeeMachine, siis omandavad nad ka neid üleval toodud meetodid.
Tuleb märgata, et meetod makeCoffee() on igal masinatüübil erinev. Seega, seda meetodit tulleb @Override. Loogiline on ka see, et
meetod makeCoffee() peab tagastama midagi (kohvi).

Kuna kohvimasinad on erinevad - on erinevad ka nende konstruktorid. Seega paremaks arusaamiseks mis funktsiooni ehk omaduse üks
või teine masin endas hoiab võib teha järgmist tabelit:

+------------------------------+------------------------------+------------------------------+
| CoffeMachine                 | Automated CoffeeMachine      | Capsule CoffeeMachine        |
+==============================+==============================+==============================+
| makeCoffee()                 | makeCoffee()                 | makeCoffee()                 |
+------------------------------+------------------------------+------------------------------+
| veepaak(n liitrit)           | veepaak(n liitrit)           | veepaak(n liitrit)           |
+------------------------------+------------------------------+------------------------------+
| prügikonteiner (5 jooki)     | prügikonteiner (n jooki)     | prügikonteiner (n jooki)     |
+------------------------------+------------------------------+------------------------------+
| piimapaak (n jooki)          |                              |                              |
+------------------------------+------------------------------+------------------------------+
| kohvikonteiner (n jooki)     |                              | kapsel (1 jook)              |
+------------------------------+------------------------------+------------------------------+

Nagu on tabelist näha masinatel peale makeCofffee() funktsioonit on olemas ka nö komponendid. 
Paremaks struktuuri loomiseks on mõistlik veepaagist, prügikonteinerist, piimakonteinerist ja 
kohvikonteinerist teha eraldi klassid ja panna näiteks "storages" pakki.

Veepaak
----

Loome klassi

.. code-block:: java

    public class WaterContainer {}
    
 Konstruktorisse on mõistlik panna capacity ehk palju vett saab üks või teine veepak hoida. 
 Samuti oleks hea luua muutujat (koos getter ja setteriga!) nimega constantCapacity. Ehk idee 
 on selles, et luues veepaaki - muutub constantCapacity nagu "konstandiks" ja kuna tavaline 
 capacity hakkab vastavalt kohvi valmistamisel muutuma - constantCapacity jääb samaks --> saab 
 teada, millal veepaak on tühjaks muutunud.
 
    private int capacity;
    private int constantCapacity;

    public WaterContainer(int capacity) {
        this.capacity = capacity;
        this.constantCapacity = capacity;

    }
    
 Selleks,et oleks võimalik kontrollida, kas veepaak on tühjaks läinud teeme sellest meetodit, mis võiks 
 tagastada true/false
 
     public boolean enoughWaterLeft(int amount) {
        return amount <= getCapacity();
    }
    
 Selleks, et muuta capacity, loome ka 2 järgmevat meetodit (tegelikult võib ka 1 teha)

    public void setCapacityLeft(int capacity) {
        if (capacity <= constantCapacity && capacity >= 0) {
            this.capacity = capacity;
        }
    }

    public void refillWaterContainer() {

        setCapacityLeft(getConstantCapacity());

    }
    
    Oluline on ka teha getterit capacity and constantCapacity jaoks !
    

Sarnasel realiseerime ka järgmised klassid, kus konstruktori parameetriks võiks nagu enne olla (int capacity):

.. code-block:: java

  public class BeansContainer {}
  public class MilkContainer {}
  public class RubbishContainer {}
  
  
Kui see osa on valmis tuleb mõelda, kuidas paneme masinaid valmistama erivaid jooke. Kas teeme iga konkreetse joogi jaoks oma 
eraldi klassi kus oleksid vaid getterid? Kas oleks see mõistlik? Küll mitte. Seega lahenduses on toodud imeline enum !
Iga enumi komponent võib omakorda sisalduda ka oma parameentreid, mis võiksid olla näiteks: "vesi", "kohv" ja "piim" -> 
nende vajadus ühe või teise joogi jaoks.

.. code-block:: java


    public enum DrinkType {

    BLACK_COFFEE(250, 16, 0), CAPPUCHINO(120, 13, 80), COFFEE_LATTE(50, 10, 130),
    ESPRESSO(25, 12, 0), DOUBLE_ESPRESSO(50, 24, 0), WATER(250, 0, 0);


    private int waterMililiters;
    private int beans;
    private int milkMililiters;

    DrinkType(int waterLiters, int beans, int milkLiters) {
        this.waterMililiters = waterLiters;
        this.beans = beans;
        this.milkMililiters = milkLiters;
    }
    
    + getterid !!!
  
Järgmisena võime hakata kohvimasinate loomisega.
See lahendusvariant lähtub järgmisest loogikast: kui me soovime luua (või näiteks ütleme "osta") kohvimasinat, 
ei pea me selleks eralsi luua veepaaki, prügikonteinerit, piimapaaki jne. Sõltuvalt, mis masinat me loome, võiks sisaldada 
ta juba enda sees neen komponendid (objektid). Seega:

.. code-block:: java

  public class CoffeeMachine {

    RubbishContainer rubbishContainer;
    WaterContainer waterContainer;
    private BeansContainer beansContainer;
    private MilkContainer milkContainer;


    public CoffeeMachine() {

        this.rubbishContainer = new RubbishContainer(5);
        this.waterContainer = new WaterContainer(1500);
        this.beansContainer = new BeansContainer(250);
        this.milkContainer = new MilkContainer(1000);

    }
    
    Automaatse kohvimasina puhul ei pea arvestama, et kohvioad või piim (v.a. vesi) otsa võiks saada. Seega, 
    kuna CoffeeMachine on AutomatedCoffeeMachine ülemklass kõik jääb samaks, aga me teeme automaatmasina 
    prükonteineri mahtuvust suurem
    
        public AutomatedCoffeeMachine() {
        this.rubbishContainer = new RubbishContainer(25);

    }
    
    Kapselmasina puhul lisandub ka parameeter "Kapsel" - ehk siis see, mille abil saab kohvi saada
    
    Kapsel
    ----
    
    Kapsel on mõistlik teha eraldi klassina, mis võiks paikneda ka "storages" pakkis. Kuna kapslid võivad erinevad olla, siis
    konstruktori parameetriks võiks anda enumi jooki. Kuna tingimuses on see, et ühest kapslist saab ühte jooki teha -> siis
    tuleb ka arvestama sellega, et kas pärast jooki valmistamist oli kapsel ära võetud. Samuti on juhul kui soovitakse jooki 
    teha -> Kontroll kas kapsel on üldse masinas olemas? Loogika võib olla realiseeritud järgmisel moel:
    
   
      public class Capsule {

      private DrinkType type;
      private boolean isEmpty = false;


      public Capsule(DrinkType type) {
          this.type = type;
      }

      public boolean isEmpty() {
          return isEmpty;
      }

      public void isUsed() {
          isEmpty = true;
      }
      
    Siis, kui kapsel on valmis, saame ka kapslimasina klassi valmis teha
    
    
        private Capsule capsule;

        public CapsuleCoffeeMachine() {

        this.rubbishContainer = new RubbishContainer(7);
        this.waterContainer = new WaterContainer(1500);
        

    }
    
    Võiks öelda, et kapselmasin on kõikidest masinatest veits keerulisem, sest tuleb peale tabalist konteinereid vaadata ka
    kapsli seis (kas on või ei ole). Seda aitavad teha järgmised meetodid:
    
    public void insertCapsule(Capsule capsule) {
        this.capsule = capsule;
    }

    public void removeCapsule() {
        capsule = null;
    }

    public boolean isCapsuleIsInside() {
        return capsule != null;
    }
    
    Need on nö kontrollid tänu millele hakkame me kas kohvi või "tühja kovhi" (vett) valmistama.

Exception
----

Tundub, et on aeg lõpuks realiseerida makeCoffee() meetodit. Aga teeme enne veel excpectionit, mida hakkame viskama juhul,
kui mingi resurss saab otsa. Exception võib sisaldada endas enumit ja olla realiseeritud sarnasel viisil: 


.. code-block:: java
    
    public class CannotDoException extends Exception {

      private Reason reason;

      public enum Reason {
          NOT_ENOUGH_COFFEE, RUBBISH_CONTAINER_IS_FULL, NOT_ENOUGH_MILK,
          NOT_ENOUGH_WATER, NO_SUCH_MACHINE_EXIST_IN_THIS_KITCHEN
      }

      public CannotDoException(Reason reason) {
          this.reason = reason;
      }

      public Reason getReason() {
          return reason;
      }
}
    
    Exceptionit on mõistlik hoida pakkis "exception"
    

Nüüd vaatame, kuidas võiks ikka see makeCoffee() meetod välja nägema. Nagu oli juba enne mainitud, iga AutomatedCoffeMachine()
ja CapsuleCoffeeMachine() puhul peab see meetod olema @Override - mis tähendab, et me ülekirjutame antud ülemklassis see meetod.
makeCoffee() võiks võtta parameetriks DrinkType type - ehk kindlat jooki, mida soovitatakse valmis teha.
Juhul, kui me ei saa kohvi valmis teha -> viskame exceptionit ja selleks tuleb meetodi kõrvale panna vastavat signatuuri
(throws CannotDoException). Kui ei pane, siis IntelliJ pakub sulle ta ise panna.

.. code-block:: java

    public Drink makeCoffee(DrinkType type) throws CannotDoException {





    
   
   
    
    
   
    
    
    
    










    
